\documentclass{article}

\usepackage{parskip}

\begin{document}

\section{Introduction}
Je vais présenter dans ce rapport le travail réalisé pour la conception d'un interpréteur du langage \textit{Kawa}. L'ensemble de la partie minimale du projet a été réalisée. Une partie des 
extensions a également été réalisée. Ce rapport sera donc organisé en deux partie: la première présentera le travail réalisé pour la partie minimale, la seconde présentera les différentes 
extensions réalisées.

L'ensemble du code se trouve sur le \textbf{Git}. On peut retrouver la partie minimale (sans extensions) dans la branche \textbf{Kawa\_v1} et la partie avec entensions dans la 
branche \textbf{Kawa}.

\section{Implémentation minimale}
J'ai d'abord commencé par compléter le lexer et le parser. Une fois le parser complété, j'ai compilé puis corrigé les quelques erreurs qu'il pouvait y avoir.
Cette partie terminée, j'ai pu commencé à implémenter l'interpréteur.

L'interpréteur gère les différentes instructions et expressions du langage. Les expressions d'opérations sont plutôts simples, on évalue les expressions puis on effectue les opérations.
D'autres expressions et instructions demandent plus d'opérations.
L'expression \textbf{new} doit créer un nouvel objet. Si l'objet n'hérite de rien, on peut créer l'environnement et rendre un nouvelle objet avec cet environnement. Si l'objet hérite, 
on va créer l'objet parent (qui lui même va créer ses parents s'il en a), on récupère l'environnement de l'objet parent pour y ajouter les attributs de l'objet fils.
Une partie intéressante de l'interpréteur est l'appel de méthodes. Pour l'appel de méthode on va d'abord recherche la méthode à partir du nom donné. On peut ensuite appeler \textit{eval\_call} 
avec la méthode, l'objet et les paramètres de la méthode. Il faut ajouter l'objet lui-même à l'environnement qui permettra l'utilisation du mot clé \textit{this} et également les paramètres 
donnés. Une fois l'environnement de l'appel complet, on peut exécuter la séquence d'instructions de la méthode.
Pour terminer avec l'interpréteur j'ai ajouté une table de hachage pour pouvoir récupérer rapidement les classes 
à partir du nom de la classe et ainsi que la possibilité d'afficher tous les types avec \textbf{Print}.

Une fois l'interpréteur terminé j'ai pu commencé à le tester. À ce niveau il est possible d'exécuter du code mais une erreur de 
typage va lever une erreur sans donner plus d'information ou bien le programme pourrait avoir un comportement non 
souhaité. Je me suis ensuite penché sur la vérification des types du programme. 

La vérification du typage passe d'abord par la vérification du typage des classes puis par la vérification du 
\textit{main}. Comme pour l'interpréteur il faut vérifier les instructions et les expressions. Pour la plupart 
c'est plutôt simple, on vérifie le typage et si tout est bon on renvoie le type produit. C'est la cas par exemple 
pour toutes les opérations binaires. D'autres opérations demandent un peu plus de vérification. C'est le cas de 
\textbf{SET} qui pour un objet doit vérifier que l'objet donné est du même type que la variable ou bien est un 
sous-type de la variable. De manière similaire, pour l'accès mémoire en notation pointée et l'appel de méthode il
 faut vérifier que l'attribut est dans la classe ou dans l'une de ses classes mères.

\section{Extensions}
J'ai implémenté les extensions suivantes:
\begin{itemize}
    \item Champs immuables
    \item Visibilités
    \item Déclarations en série
    \item Déclarations avec valeur initiale
    \item Champs statiques
    \item Test de type
    \item Transtypage
    \item Super
    \item Tableaux
    \item Egalité structurelle
    \item "Did you mean 'recursion' ?"
    \item Le processus ne peut pas aboutir en raison d'un problème technique
    \item "Missing Semicolon"
\end{itemize}

Ces extensions ont posées plus ou moins de difficultés et ont nécessitées différents changements dans le code.
Nous allons revenir sur les différents changements faits pour mettre en place ces extensions.

\subsection{Champs immuables}
Les champs immuables ont nécessités la modification du typechecker. Il faut en effet vérifier que les accès mémoire 
sur des attributs \textit{Final} ne se fassent pas avec \textbf{SET}. On peut cependant y accéder avec \textbf{GET}.
C'est pourquoi j'ai créé une exception \textbf{Final} qui indique que la variable demandée est final. C'est ensuite 
à \textit{SET} et \textit{GET} de gérer cette exeption (pour SET on lève une erreur).
L'information qu'une variable est immuable ou non est liée à la visibilité de la variable (voir \ref{visib}).

\subsection{Visibilités}
\label{visib}
La visibilité des attributs a nécessité plusieurs modifications. D'abord j'ai ajouté un type \textbf{visibility} 
qui contient les différentes visibilités possibles pour une variable. Les visibilités telles que \textbf{FPRIVATE} 
commencent par un \textbf{F} pour indiquer que l'attribut est immuable (Final). Les variables globales ont une 
visibilité \textbf{UNDEFINED}. Cela permet de traiter les variables globales comme les attributs.
Ensuite j'ai ajouté un type \textbf{global\_def} qui permet de récupérer les attributs et les méthodes. En effet si 
on ajoute les mots clés PRIVATE et PROTECTED et qu'on récupère les attributs puis les méthodes on obtient un conflit 
à cause des listes. Avec ce système on récupère une liste d'attributs et de méthodes donc plus de conflits.
Les attributs et les méthodes sont ensuite trié quand on récupère une classe. On revient au comportement qu'on 
avait avant d'ajouter les visibilités et il suffit ensuite de vérifier lors de l'accès mémoire qu'on a le droit 
d'y accéder avec la visibilité associé à la variable.

\subsection{Déclarations en série}
La déclaration en série se fait grâce au type \textit{var\_decl} qui renvoie une liste de déclaration. Si une 
seule variable est déclarée on renvoie une liste avec un seul élément. Sinon on renvoie une liste de variables 
qui sera ensuite ajouté aux déclarations.

\subsection{Déclarations avec valeur initiale}
Pour la déclaration avec valeur initiale j'ai ajouté une nouvelle instruction \textbf{SETDEF} qui permet de traiter les déclarations 
avec valeur initiale différemment pour les classes. Pour les variables globales il suffit de récupérer les variables 
avec une expression puis d'ajouter au code un SET(variable, expression) (cette opération est réalisée dans le Parser). 
Ainsi quand le code s'exécute on donne bien une valeur à la variable. Cette méthode ne fonctionne plus avec les classes 
car par exemple si notre attribut est statique et immuable on ne va pas pouvoir ajouter un SET pour donner la valeur.
C'est la raison pour laquelle j'ai ajouté SETDEF qui permet d'ignorer ces paramètres des variables.

\subsection{Champs statiques}
Un nouveau type de variable a été créé. Il permet de mettre ces variables à part pour les stocker non pas avec les 
autres mais dans un champs spécial de la classe. Ils sont ensuite géré comme une variable globale dans l'interpréteur.
Les champs statiques ont pour clé dans l'environnement \textbf{NomClasse.attribut}. Comme les variables ne peuvent 
pas contenir de point on sait que ce nom sera unique dans l'environnement. Cela simplifie également l'accès car 
lorsqu'on a récupéré le nom de la classe et de l'attribut on peut directement y accèder dans l'environnement.

\subsection{Test de type}
Le test de type ajoute une expression \textbf{InstanceOf} qui prend une expression et une chaine de caractère. On vérifie que la chaine 
de caractère est un nom de classe valide et que l'expression est de type \textit{Tclass}. L'interpréteur vérifie ensuite si l'objet 
ou l'un des parents de l'objet est du type donné.

\subsection{Transtypage}
Le transtypage ajoute une expression \textbf{Cast} qui prend deux expressions. Le nom de classe pour le Cast est une expression et 
non pas une chaine de caractères. La raison est qu'une chaine de caractères cause un conflit avec l'expression parenthésée. J'ai 
donc décidé de mettre une expression qui doit être \textit{Get (Var classe, ...)} avec "classe" la classe du cast (on vérifie 
ça dans le typechecker).
Une fois ces informations récupérer, le typechecker n'ayant accès qu'au type statique il doit vérifier que la classe du cast 
est une classe fille ou une classe mère de la classe à cast. Enfin l'interpréteur doit également vérifier que la classe du 
cast est une classe fille du type dynamique. Si toutes ces vérifications sont valides l'interpréteur renvoie l'objet.

\subsection{Super}
\textbf{Super} est une nouvelle expression. Cette expression fonctionne comme le mot clé \textit{This}. La différence est qu'au lieu 
de faire référence à l'objet courant ("this" dans l'environnement), cette expression va récupérer "this" puis rendre la classe mère.
Ainsi un accès avec Super va rechercher directement dans la classe mère ou ses classes mères.

\subsection{Tableaux}
Les tableaux sont créés grâce à un nouveau type \textbf{TArray a}. Les tableaux sont stockés via les tableaux ocaml. Un tableau 
est créé à partir d'une taille et d'un type. L'interpréteur va initialiser les éléments du tableau à Null. Pour un tableau 
à plusieurs dimensions, tous les tableaux sont initialisés et il est possible d'accéder et de donner une valeur directement aux 
éléments des tableaux. Le typechecker va vérfier que tous les éléments du tableau sont du même type.

\subsection{Egalité structurelle}
L'égalité structurelle vérifie que les attributs des deux objets ont la même valeur.

\subsection{"Did you mean 'recursion' ?"}
Cette extension a été très intéressante à implémenter. Il a fallu trouver un moyen de rechercher le mot le plus proche dans une liste. 
Pour trouver le mot le plus proche j'ai utilisé la distance de Levenshtein. J'ai créer un module \textit{wordcomp.ml} qui gère les 
comparaisons dans lequel j'ai implémenté les fonctions necéssaires. Il suffit ensuite de faire des appels lorsqu'un identifiant 
n'est pas trouvé dans l'environnement.

\subsection{Le processus ne peut pas aboutir en raison d'un problème technique}
Cette extension ajoute simplement un champ \textbf{Lexeme.position} qui est récupéré via le parser. On peut ensuite récupérer la ligne 
dans le typechecker et l'afficher en cas d'erreur.

\subsection{"Missing Semicolon"}
L'interpréteur indique les erreurs de point-virgule et les erreurs d'accolades. Pour cela j'utilise le symbole \textit{error} qui permet 
de lever une exception en cas d'erreur.

\end{document}